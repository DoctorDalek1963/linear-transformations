% lintrans - The linear transformation visualizer
% Copyright (C) 2021-2022 D. Dyson (DoctorDalek1963)

% This program is licensed under GNU GPLv3, available here:
% <https://www.gnu.org/licenses/gpl-3.0.html>

\documentclass[../main.tex]{subfiles}

\begin{document}

\subsection{Problem decomposition\label{design:problem-decomposition}}

I have decomposed the problem of visualization as follows:
\begin{center}
\begin{tikzpicture}[
	every node/.style={rectangle, minimum size=6mm, draw=black, font=\ttfamily, align=center, very thick},
	every path/.style={very thick},
	root/.style={rectangle, text=white, fill=black},
	module/.style={text=black, grow=down, anchor=west, edge from parent path={\tikzparentnode.south |- \tikzchildnode.west}},
	vertical/.style={grow=down, xshift=1em, anchor=west, edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}, level distance={#1*6ex}},
	level 1/.style={sibling distance=9.5em},
]
\node [root] {Visualize} [grow=down, level distance=9ex] [edge from parent fork down]
	child {node {Define\\matrices}}
	child {node {Evaluate\\expressions}
		child [vertical=1] {node [module] {Validate}}
		child [vertical=2] {node [module] {Parse}}
		child [vertical=3] {node [module] {Compute}}
	}
	child {node {Render\slash animate}
		child [vertical=1] {node [module] {Evaluate\\positions}}
		child [vertical=2.5] {node [module] {Render\\widget}}
	};
\end{tikzpicture}
\end{center}
Defining matrices is key to visualization because we need to have matrices to actually visualize. This is a key part of the app, and the user will be able to define multiple separate matrices numerically and visually using the GUI.

Evaluating expressions is another key part of the app and can be further broken down into validating, parsing, and computing the value. Validating an expression simply consists of checking that it adheres to a set of syntax rules for matrix expressions, and that it only contains matrices which have already been defined. Parsing consists of breaking an expression down into tokens, which are then much easier to evaluate. Computing the expression with these tokens is then just a series of simple operations, which will produce a final matrix at the end.

Rendering and animating will likely be the largest part in reality, but I've only decomposed it into simple blocks here. Evaluating positions involves evaluating the matrix expression that the user has input and using the columns of the resultant matrix to find the new positions of the basis vectors, and then extrapolating this for the rest of the plane. Rendering onto the widget is likely to be quite complicated and framework-dependent, so I've abstracted away the details for brevity here. Rendering will involve using the previously calculated values to render grid lines and vectors. Animating will probably be a \texttt{for} loop which just renders slightly different matrices onto the widget and sleeps momentarily between frames.

I have deliberately broken this problem down into parts that can be easily translated into modules in my eventual coded solution. This is simply to ease the design and development process, since now I already know my basic project structure. This problem could've been broken down into the parts that the user will directly interact with, but that would be less useful to me when actually starting development, since I would then have to decompose the problem differently to write the actual code.

\subsection{Structure of the solution\label{design:structure-of-the-solution}}

I have decomposed my solution like so:

\begin{figure}[H]
\begin{minipage}{0.35\linewidth}
\begin{center}
\begin{tikzpicture}[
	every node/.append style={
		rectangle,
		minimum size=6mm,
		draw=black,
		font=\ttfamily,
		align=center,
		very thick,
		anchor=west
	},
	every path/.style={very thick},
	root/.style={rectangle, text=white, fill=black},
	package/.style={text=white, fill=gray},
	module/.style={text=black},
	grow via three points={one child at (0.5,-0.8) and two children at (0.5,-0.8) and (0.5,-1.6)},
	edge from parent path={(\tikzparentnode\tikzparentanchor) |- (\tikzchildnode\tikzchildanchor)}
]
\node [root] {lintrans}
	child {node [module] {\_\_main\_\_}}
	child {node [module] {global\_settings}}
	child {node [package] {gui}
		child {node [module] {main\_window}}
		child {node [module] {session}}
		child {node [module] {settings}}
		child {node [package] {dialogs}
			child {node [module] {define\_new\_matrix}}
			child {node [module] {misc}}
			child {node [module] {settings}}
		}
		child [missing] {}
		child [missing] {}
		child [missing] {}
		child {node [package] {plots}
			child {node [module] {classes}}
			child {node [module] {widgets}}
		}
		child [missing] {}
		child [missing] {}
	}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child [missing] {}
	child {node [package] {matrices}
		child {node [module] {parse}}
		child {node [module] {utility}}
		child {node [module] {wrapper}}
	};
\end{tikzpicture}
\end{center}
\end{minipage}\hfill
\begin{minipage}{0.55\linewidth}
\setlength{\parskip}{1em}
The \texttt{lintrans} node is simply the root of the whole project. \texttt{__main__} is the Python way to make the project executable as \texttt{python -m lintrans} on the command line. For release, I will package it into a standalone binary executable, using this module as the entry point.

The \texttt{global_settings} module will define a \texttt{GlobalSettings} singleton class. This class will manage global settings and variables - things like where to save sessions by default, etc. I'm not entirely sure what I want to put in here, but I expect that I'll want global settings in the future. Having this class will allow me to easily read and write these settings to a file to have them persist between sessions.

\texttt{matrices} is the package that will allow the user to define, validate, parse, evaluate, and use matrices. The \texttt{matrices.parse} module will contain functions to validate matrix expressions - likely using regular expressions - and functions to parse matrix expressions. It will not know which matrices are defined, so validation will be na\"{i}ve and evaluation will be in the \texttt{matrices.wrapper} module. This \texttt{wrapper} module will contain a \texttt{MatrixWrapper} class, which will hold a dictionary of matrix names and values. It is this class which will have aware validation - making sure that all the matrices used in an expression are actually defined in the wrapper - as well the ability to evaluate matrix expressions, in addition to its basic behaviour of setting and getting matrices by name. There will also be a \texttt{matrices.utility} module, which will contain some simple functions for simple functionality. Functions like \texttt{create_rotation_matrix()}, which will generate a rotation matrix from an angle using the formula $\begin{psmallmatrix}\cos\theta & -\sin\theta\\\sin\theta & \cos\theta\end{psmallmatrix}$.
\end{minipage}
\end{figure}

\texttt{gui} is the package that will contain all the frontend code for everything GUI-related. \texttt{gui.main_window} is the module that will define the \texttt{LintransMainWindow} class, which will act as the main window of the application and have an instance of \texttt{MatrixWrapper} to keep track of which matrices are defined and allow for evaluation of matrix expressions. It will also have methods for rendering and animating matrix expressions, which will be connected to buttons in the GUI. The most important part of the main window is the viewport, which will be discussed shortly. This module will also contain a simple \texttt{main()} function to instantiate and launch the application GUI.

The \texttt{gui.session} module will contain functions to save and load a session from a file. A session will consist of the \texttt{MatrixWrapper}, along with perhaps the display settings and maybe some other things. I know that saving the wrapper will be essential, but I'll see what else should be saved as the project evolves.

The \texttt{gui.settings} module will contain a \texttt{DisplaySettings} dataclass\footnote{This is the Python equivalent of a \texttt{struct} or \texttt{record} in other languages} that will represent the settings for visualizing transformations. The viewport class will have an instance of this class and check against it when rendering things. The user will be able to open a dialog to change these display settings, which will update the main window's instance of this class.

The \texttt{gui.dialogs} subpackage will contain modules with different dialog classes. It will have a \texttt{gui.dialogs.define_new_matrices} module, which will have a \texttt{DefineDialog} abstract superclass. It will then contain classes that inherit from this superclass and provide dialogs for defining new matrices visually, numerically, and as an expression in terms of other matrices. Additionally, it will contain a \texttt{gui.dialogs.settings} module, which will provide a \texttt{SettingsDialog} superclass and a \texttt{DisplaySettingsDialog} class, which will allow the user to configure the aforementioned display settings. It may also have a \texttt{GlobalSettingsDialog} class in the future, which would similarly allow the user to configure the app's global settings through a dialog. This will only be implemented once I've actually got global settings to configure.

The \texttt{gui.dialogs.misc} module will contain small miscellaneous dialog boxes - things like the about box which are very simple and don't need a dedicated module.

The \texttt{gui.plots} subpackage will have a \texttt{gui.plots.classes} module and a \texttt{gui.plots.widgets} module. The \texttt{classes} module will have the abstract superclasses \texttt{BackgroundPlot} and \texttt{VectorGridPlot}. The former will provide helper methods to convert between coordinate systems and draw the background grid, while the latter will provide helper methods to draw transformations and their components. It will have \texttt{point_i} and \texttt{point_j} attributes and will provide methods to draw the transformed version of the grid, the vectors and their arrowheads, the eigenlines of the transformation, etc. These methods can then be called from the Qt5 \texttt{paintEvent} handler which will be declared abstract and must therefore be implemented by all subclasses.

The \texttt{gui.plots.widgets} module will have the classes \texttt{VisualizeTransformationWidget} and \texttt{DefineVisuallyWidget}, which will both inherit from \texttt{VectorGridPlot}. They will both implement their own \texttt{paintEvent} handler to actually draw the respective widgets, and \texttt{DefineVisuallyWidget} will also implement handlers for mouse events, allowing the user to drag around the basis vectors.

I also want the user to be able to define arbitrary polygons and view their transformations. I imagine this polygon definition will happen in a separate dialog, but I don't know where that's going to fit just yet. I'll probably have the widget in \texttt{gui.plots.widgets}, but possibly elsewhere.

\subsection{Algorithm design\label{design:algorithm-design}}

The project will have many algorithms and a lot of them will be related to drawing transformations on the canvas itself, but almost all of the algorithms will evolve over time. In this section, I will present pseudocode for some of the most interesting parts of the project. The real implementations may be different from these initial plans.

The \texttt{lintrans.matrices.utility} module will look roughly like this:

\begin{minted}{lexers.py:OCRPseudocodeLexer -x}
import numpy as np // Python import

// Create a matrix representing a rotation (anticlockwise) by the given angle
function create_rotation_matrix(angle: float, degrees: bool = True) -> MatrixType
	if (degrees) then
		rad = np.deg2rad(angle MOD 360)
	else
		rad = angle MOD (2 * np.pi)
	endif

	return np.array([
		[np.cos(rad), -1 * np.sin(rad)],
		[np.sin(rad), np.cos(rad)]
	])
endfunction
\end{minted}

And the \texttt{lintrans.matrices.wrapper} module will look like this:

\begin{minted}{lexers.py:OCRPseudocodeLexer -x}
import re
import numpy as np

// The `.utility` syntax means that the utility module is next to this one in the tree
from .utility import create_rotation_matrix

class MatrixWrapper
	// This is a hashmap from string to matrices, but the matrices might be null
	private matrices: Dict[string, Optional[MatrixType]]

	public procedure new()
		matrices = {
			"A": null, "B": null, "C": null, "D": null,
			"E": null, "F": null, "G": null, "H": null,
			"I": np.eye(2),  // I is always defined as the identity matrix
			"J": null, "K": null, "L": null, "M": null,
			"N": null, "O": null, "P": null, "Q": null,
			"R": null, "S": null, "T": null, "U": null,
			"V": null, "W": null, "X": null, "Y": null,
			"Z": null
		}
	endprocedure

	// This is a Python "magic method", which enable syntax like `wrapper['A']` to get the matrix A
	public function getitem(name: string) -> Optional[MatrixType]
		// If it is a simple name, it will just be fetched from the dictionary. If the name is ``rot(x)``, with
		// a given angle in degrees, then we return a new matrix representing a rotation by that angle

		// Return a new rotation matrix
		match = re.match(r"^rot\((-?\d*\.?\d*)\)$", name)
		if (match != null)
			return create_rotation_matrix(float(match.group(1)))
		endif

		if (!matrices.contains(name))
			raise NameError(f'Unrecognised matrix name "{name}"')
		endif

		return matrices[name]
	endfunction

	// Again, this is Python magic. This one allows assignments like `wrapper['A'] = my_matrix`
	public procedure setitem(name: string, new_matrix: Optional[MatrixType])
		// If new_matrix is null, then that effectively unsets the matrix name.

		if (name == "I" OR !matrices.contains(name))
			raise NameError("Matrix name is illegal")
		endif

		if (new_matrix == null)
			matrices[name] = null
			return
		endif

		if (!is_matrix_type(new_matrix))
			raise TypeError("Matrix must be a 2x2 NumPy array")
		endif

		// All matrices must have float entries
		a = float(new_matrix[0][0])
		b = float(new_matrix[0][1])
		c = float(new_matrix[1][0])
		d = float(new_matrix[1][1])

		matrices[name] = np.array([[a, b], [c, d]])
	endprocedure
endclass
\end{minted}

The \texttt{lintrans.gui.plots.classes} module will contain the following utility functions:

\begin{minted}{lexers.py:OCRPseudocodeLexer -x}
from PyQt5.QtGui import QPainter
from PyQt5.QtWidgets import QWidget

const DEFAULT_GRID_SPACING: int = 85

// This class will act as a baseclass for the viewport and visual defintion dialog.
// They will both use different subclasses of this class to visualize things on a grid.
// Canvas coordinates are the coordinates that Qt5 uses internally. These are standard
// computer graphics coordinates, with (0, 0) in the top left, positive x to the right,
// and positive y going down.
class BackgroundPlot extends QWidget
	private grid_spacing: int

	public procedure new()
		super.new()

		grid_spacing = DEFAULT_GRID_SPACING
	endprocedure

	// Return the canvas coordinates of the grid origin (centre)
	private function canvas_origin() -> (int, int):
		// width() and height() come from QWidget. They get the total width or height of the widget
		return (width() DIV 2, height() DIV 2)
	endfunction

	// Convert an x coordinate from grid coords to canvas coords so it can be drawn
	private function canvas_x(self, x: float) -> int
		return int(canvas_origin()[0] + x * grid_spacing)
	endfunction

	// Convert an x coordinate from grid coords to canvas coords so it can be drawn
	private function canvas_y(self, y: float) -> int
		return int(canvas_origin()[1] - y * grid_spacing)
	endfunction

	// Convert a coordinate from grid coords to canvas coords
	private function canvas_coords(x: float, y: float) -> (int, int)
		return (canvas_x(x), canvas_y(y))
	endfunction

	// Find the grid coordinates of the top right corner. We use the top right because
	// both coordinates will be positive
	private function grid_corner() -> (float, float)
		// Again, width() and height() come from QWidget
		return (width() / (2 * grid_spacing), height() / (2 * grid_spacing))
	endfunction

	// Convert a coordinate from canvas coords to grid coords
	private function grid_coords(x: int, y: int) -> (float, float)
		return (
			(x - canvas_origin[0]) / grid_spacing,
			(-y + canvas_origin[1]) / grid_spacing
		)
	endfunction

	// Draw the background grid. This method is meant to be used by subclasses when
	// they paint their whole scene
	private function draw_background(painter: QPainter)
		// Draw equally spaced vertical lines, starting in the middle and going out
		// We loop uo to half the width because we draw one line on each side of the axis per iteration
		for (int x = width() DIV 2 + grid_spacing; x < width(); x += grid_spacing)
			painter.drawLine((x, 0), (x, height()))
			painter.drawLine((width() - x, 0), (width() - x, height()))
		next x

		// Now do the same for horizontal lines
		for (int y = height() DIV 2 + grid_spacing; y < height(); x += grid_spacing)
			painter.drawLine((0, y), (width(), y))
			painter.drawLine((0, height() - y), (width(), height() - y))
		next y

		// Now draw the axes
		painter.drawLine((width() DIV 2, 0), (width() DIV 2, height()))
		painter.drawLine((0, height() DIV 2), (width(), height() DIV 2))
	endfunction
endclass
\end{minted}

These modules handle the creation, storage, and use of matrices. Their implementations are deliberately simple, since they don't have to do much. I will eventually extend the \texttt{MatrixWrapper} class to allow strings as matrices, so they can be defined as expressions, but this is unnecessary for now. It will simply be more conditions in \texttt{__getitem__} and \texttt{__setitem__} and a method to evaluate expressions.

Parsing matrix expressions will be quite tricky and I don't really know how I'm going to do it. I think it will be possible with regular expressions, since I won't support nested expressions at first. But adding support for nested expressions may require something more complicated. I will have a function to validate a matrix expression, which can definitely be done with regular expressions, and I'll have another public function to parse matrix expressions, although this one may use some private functions to implement it properly.

I'm not sure on any algorithms yet, but here's the full BNF specification for matrix expressions (including nested expressions):

\begin{minted}{bnf}
expression        ::=  [ "-" ] matrices { ( "+" | "-" ) matrices };
matrices          ::=  matrix { matrix };
matrix            ::=  [ real_number ] matrix_identifier [ index ] | "(" expression ")";
matrix_identifier ::=  "A" .. "Z" | "rot(" [ "-" ] real_number ")";
index             ::=  "^{" index_content "}" | "^" index_content;
index_content     ::=  [ "-" ] integer_not_zero | "T";

digit_no_zero     ::=  "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
digit             ::=  "0" | digit_no_zero;
digits            ::=  digit | digits digit;
integer_not_zero  ::=  digit_no_zero [ digits ];
real_number       ::=  ( integer_not_zero [ "." digits ] | "0" "." digits );
\end{minted}

Obviously the data structure returned by the parser is very important. I have decided to use \texttt{list[list[tuple[str, str, str]]]}. Each tuple represents a real number multiplier, a matrix identifier, and an index. The multiplier and index may be empty strings. These tuples are contained in lists which represent matrices to be multiplied together, in order. Those lists are contained in a top level list, which represents multiplication groups which should be summed.

This type makes the structure of the input clear, and makes it very easy for the \texttt{MatrixWrapper} to evaluate a parsed expression.

\subsection{Usability features\label{design:usability-features}}

My main concern in terms of usability is colour. In the 3blue1brown videos on linear algebra, red and green are used for the basis vectors, but these colours are often hard to distinguish in most common forms of colour blindness. The most common form is deuteranopia\cite{types-of-color-blindness}, which makes red and green look incredibly similar. I will use blue and red for my basis vectors. These colours are easy to distinguish for people with deuteranopia and protanopia - the two most common forms of colour blindness. Tritanopia makes it harder to distinguish blue and yellow, but my colour scheme is still be accessible for people with tritanopia, as red and blue are very distinct in this form of colour blindness.

I will probably use green for the eigenvectors and eigenlines, which will be hard to distinguish from the red basis vector for people with red-green colour blindness, but I think that the basis vectors and eigenvectors/eigenlines will look physically different enough from each other that the colour shouldn't be too much of a problem. Additionally, I will use a tool called Color Oracle\cite{colororacle.org} to make sure that my app is accessible to people with different forms of colour blindness\footnote{I actually had to clone a fork of this project\cite{color-oracle-dorkbox-fork} to get it working on Ubuntu 20.04 and adapt it slightly to create a working \texttt{jar} file\cite{color-oracle-my-fork}}.

Another solution would be to have one default colour scheme, and allow the user to change the colour scheme to something more accessible for colour blind people, but I don't see the point in this. I think it's easier for colour blind people to just have the main colour scheme be accessible, and it's not really an inconvenience to non-colour blind people, so I think this is the best option.

The layout of my app will be self-consistent and follow standard conventions. I will have a menu bar at the top of the main window for actions like saving and loading, as well as accessing the tutorial (which will also be accessible by pressing \texttt{F1} at any point) and documentation. The dialogs will always have the confirm button in the bottom right and the cancel button just to the left of that. They will also have the matrix name drop-down on the left. This consistency will make the app easier to learn and understand.

I will also have hotkeys for everything that can have hotkeys - buttons, checkboxes, etc. This makes my life easier, since I'm used to having hotkeys for everything, and thus makes the app faster to test because I don't need to click everything. This also makes things easier for other people like me, who prefer to stay at the keyboard and not use the mouse. Obviously a mouse will be required for things like dragging basis vectors and polygon vertices, but hotkeys will be available wherever possible to help people who don't like using the mouse or find it difficult.

\subsection{Variables and validation\label{design:variables-and-validation}}

The most important variables in the project will be instance attributes on the \texttt{LintransMainWindow} class. It will have a \texttt{MatrixWrapper} instance, a \texttt{DisplaySettings} instance, and most importantly, a \texttt{VisualizeTransformationWidget} instance. These will handle the matrices and various settings respectively. Having these as instance attributes allows them to be referenced from any method in the class, and Qt5 uses lots of slots (basically callback methods) and handlers, so it's good to be able to access the attributes I need right there rather than having to pass them around from method to method.

The \texttt{MatrixWrapper} class will have a dictionary of names and matrices. The names will be single letters\footnote{I would make these \texttt{char} but Python only has a \texttt{str} type for strings} and the matrices will be of type \texttt{MatrixType}. This will be a custom type alias representing a $2 \times 2$ \texttt{numpy} array of floats. When setting the values for these matrices, I will have to manually check the types. This is because Python has weak typing, and if we got, say, an integer in place of a matrix, then operations would fail when trying to evaluate a matrix expression, and the program would crash. To prevent this, we have to validate the type of every matrix when it's set. I have chosen to use a dictionary here because it makes accessing a matrix by its name easier. We don't have to check against a list of letters and another list of matrices, we just index into the dictionary.

The settings dataclasses will have instance attributes for each setting. Most of these will be booleans, since they will be simple binary options like \textit{Show determinant}, which will be represented with checkboxes in the GUI. The \texttt{DisplaySettings} dataclass will also have an attribute of type \texttt{int} representing the time in milliseconds to pause during animations.

The \texttt{DefineDialog} superclass have a \texttt{MatrixWrapper} instance attribute, which will be a parameter in the constructor. When \texttt{LintransMainWindow} spawns a definition dialog (which subclasses \texttt{DefineDialog}), it will pass in a copy of its own \texttt{MatrixWrapper} and connect the \texttt{accepted} signal for the dialog. The slot (method) that this signal is connected to will get called when the dialog is closed with the \textit{Confirm} button\footnote{Actually when the dialog calls \texttt{.accept()}. The \texttt{Confirm} button is actually connected to a method which first takes the info and updates the instance \texttt{MatrixWrapper}, and then calls \texttt{.accept()}}. This allows the dialog to mutate its own \texttt{MatrixWrapper} object and then the main window can copy that mutated version back into its own instance attribute when the user confirms the change. This reduces coupling and makes everything easier to reason about and debug, as well as reducing the number of bugs, since the classes will be independent of each other. In another language, I could pass a pointer to the wrapper and let the dialog mutate it directly, but this is potentially dangerous, and Python doesn't have pointers anyway.

Validation will also play a very big role in the application. The user will be able to enter matrix expressions and these must be validated. I will define a BNF schema and either write my own RegEx or use that BNF to programmatically generate a RegEx. Every matrix expression input will be checked against it. This is to ensure that the matrix wrapper can actually evaluate the expression. If we didn't validate the expression, then the parsing would fail and the program could crash. I've chosen to use a RegEx here rather than any other option because it's the simplest. Creating a RegEx can be difficult, especially for complicated patterns, but it's then easier to use it. Also, Python can compile a RegEx pattern, which makes it much faster to match against, so I will compile the pattern at initialization time and just compare expressions against that pre-compiled pattern, since we know it won't change at runtime.

Additionally, the buttons to render and animate the current matrix expression will only be enabled when the expression is valid. Textboxes in Qt5 emit a \texttt{textChanged} signal, which can be connected to a slot. This is just a method that gets called whenever the text in the textbox is changed, so I can use this method to validate the input and update the buttons accordingly. An empty string will count as invalid, so the buttons will be disabled when the box is empty.

I will also apply this matrix expression validation to the textbox in the dialog which allows the user to define a matrix as an expression involving other matrices, and I will validate the input in the numeric definition dialog to make sure that all the inputs are floats. Again, this is to prevent crashes, since a matrix with non-number values in it will likely crash the program.

\subsection{Iterative test data\label{design:iterative-test-data}}

There is a Python library called \texttt{pytest}, which can be used to run unit tests\cite{pytest-docs}. Unit tests are automatic tests that I can run whenever I like\cite{wikipedia-unit-testing}. I can also set these up to be run automatically by using GitHub Actions\cite{github-actions-docs}. Doing this will make it easy to test my code, because I can write separate testing code which makes sure that all my backend functions work as intended. This testing code is easy to run, and can be run automatically after every change, so I know that my changes won't break previous behaviour. All the unit testing code is in appendix \ref{appendix:testing-code}.

Additionally, \texttt{pytest} supports doctests\cite{pytest-docs-doctest}, which are unit tests written in the source code documentation\cite{python-3-doctest-module}. These tests are typically small, simple examples used to demonstrate how to use a function to an end user of the API (in this case, me). It is important to tests these examples to verify that the API is always correctly documented. I will use a few doctests for important functions, but I will mainly focus on unit tests.

In unit tests, I will test the validation, parsing, and generation of rotation matrices from an angle. I will also unit test the utility functions for the GUI, such as \pyinline{is_valid_float()}, which is needed to verify input when defining a matrix visually. I will not be testing the GUI in unit tests, since this is almost impossible to do automatically. Instead, I will have to regularly test the GUI manually; mostly defining matrices, thinking about what I expect them to look like, and then making sure they look like that. I don't see a way around this limitation. I will make my backend unit tests very thorough, but testing the GUI can only be done manually.

For the validation of matrix expressions, I will have data like the following:
\begin{center}
\begin{tabular}{|c|c|}
\hline
Valid & Invalid\\
\hline
\texttt{"A"} & \texttt{""}\\
\hline
\texttt{"AB"} & \texttt{"A\textasciicircum"}\\
\hline
\texttt{"-3.4A"} & \texttt{"rot()"}\\
\hline
\texttt{"A\textasciicircum2"} & \texttt{"A\textasciicircum\{2"}\\
\hline
\texttt{"A\textasciicircum T"} & \texttt{"\textasciicircum12"}\\
\hline
\texttt{"A\textasciicircum\{-1\}"} & \texttt{"A\textasciicircum3.2"}\\
\hline
\texttt{"rot(45)"} & \texttt{"A\textasciicircum B"}\\
\hline
\texttt{"3A\textasciicircum\{12\}"} & \texttt{".A"}\\
\hline
\texttt{"2B\textasciicircum2+A\textasciicircum TC\textasciicircum\{-1\}"} & \texttt{"--A"}\\
\hline
\texttt{"3.5A\textasciicircum\{4\}5.6rot(19.2)\textasciicircum T-B\textasciicircum\{-1\}4.1C\textasciicircum5"} & \texttt{"A--B"}\\
\hline
\end{tabular}
\end{center}

This list is not exhaustive, mostly to save space and time, but the full unit testing code is included in appendix \ref{appendix:testing-code}.

The invalid expressions presented here have been chosen to be almost valid, but not quite. They are edge cases. I will also test blatantly invalid expressions like \texttt{"This is a matrix expression"} to make sure the validation works.

Here's an example of some test data for parsing:\vspace{-1em}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Input & Expected\\
\hline
\texttt{"A"} & \texttt{[[("", "A", "")]]}\\
\hline
\texttt{"AB"} & \texttt{[[("", "A", ""), ("", "B", "")]]}\\
\hline
\texttt{"2A+B\textasciicircum2"} & \texttt{[[("2", "A", ""), ("", "B", "2")]]}\\
\hline
\texttt{"3A\textasciicircum T2.4B\textasciicircum\{-1\}-C"} & \texttt{[[("3", "A", "T"), ("2.4", "B", "-1")], [("-1", "C", "")]]}\\
\hline
\end{tabular}
\end{center}

The parsing output is pretty verbose and this table doesn't have enough space for most of the more complicated inputs, so here's a monster one:
\begin{center}
\texttt{"2.14A\textasciicircum\{3\} 4.5rot(14.5)\textasciicircum-1 + 8.5B\textasciicircum T 5.97C\textasciicircum14 - 3.14D\textasciicircum\{-1\} 6.7E\textasciicircum T"}
\end{center}
which should parse to give:
\begin{center}
\texttt{[[("2.14", "A", "3"), ("4.5", "rot(14.5)", "-1")], [("8.5", "B", "T"), ("5.97", "C", "14")], [("-3.14", "D", "-1"), ("6.7", "E", "T")]]}
\end{center}

Any invalid expression will also raise a \texttt{MatrixParseError}, so I will check every invalid input previously mentioned and make sure it raises the appropriate error.

Again, this section is brief to save space and time. All unit tests are included in appendix \ref{appendix:testing-code}.

\subsection{Post-development test data\label{design:post-development-test-data}}

% TODO: Finish this
This section will be completed later.

\end{document}
