% lintrans - The linear transformation visualizer
% Copyright (C) 2021-2022 D. Dyson (DoctorDalek1963)

% This program is licensed under GNU GPLv3, available here:
% <https://www.gnu.org/licenses/gpl-3.0.html>

\documentclass[../main.tex]{subfiles}

\begin{document}

\subsection{Problem decomposition\label{subsection:problem-decomposition}}

I have decomposed the problem of visualization as follows:
\begin{center}
\begin{tikzpicture}[
	every node/.style={rectangle, minimum size=6mm, draw=black, font=\ttfamily, align=center, very thick},
	every path/.style={very thick},
	root/.style={rectangle, text=white, fill=black},
	module/.style={text=black, grow=down, anchor=west, edge from parent path={\tikzparentnode.south |- \tikzchildnode.west}},
	vertical/.style={grow=down, xshift=1em, anchor=west, edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}, level distance={#1*6ex}},
	level 1/.style={sibling distance=9.5em},
]
\node [root] {Visualize} [grow=down, level distance=9ex] [edge from parent fork down]
	child {node {Define\\matrices}}
	child {node {Evaluate\\expressions}
		child [vertical=1] {node [module] {Validate}}
		child [vertical=2] {node [module] {Parse}}
		child [vertical=3] {node [module] {Compute}}
	}
	child {node {Render\slash animate}
		child [vertical=1] {node [module] {Evaluate\\positions}}
		child [vertical=2.5] {node [module] {Render\\widget}}
	};
\end{tikzpicture}
\end{center}
Defining matrices is key to visualization because we need to have matrices to actually visualize. This is a key part of the app, and the user will be able to define multiple separate matrices numerically and visually using the GUI.

Evaluating expressions is another key part of the app and can be further broken down into validating, parsing, and computing the value. Validating an expression simply consists of checking that it adheres to a set of syntax rules for matrix expressions, and that it only contains matrices which have already been defined. Parsing consists of breaking an expression down into tokens, which are then much easier to evaluate. Computing the expression with these tokens is then just a series of simple operations, which will produce a final matrix at the end.

Rendering and animating will likely be the largest part in reality, but I've only decomposed it into simple blocks here. Evaluating positions involves evaluating the matrix expression that the user has input and using the columns of the resultant matrix to find the new positions of the basis vectors, and then extrapolating this for the rest of the plane. Rendering onto the widget is likely to be quite complicated and framework-dependent, so I've abstracted away the details for brevity here. Rendering will involve using the previously calculated values to render grid lines and vectors. Animating will probably be a \texttt{for} loop which just renders slightly different matrices onto the widget and sleeps momentarily between frames.

I have deliberately broken this problem down into parts that can be easily translated into modules in my eventual coded solution. This is simply to ease the design and development process, since now I already know my basic project structure. This problem could've been broken down into the parts that the user will directly interact with, but that would be less useful to me when actually starting development, since I would then have to decompose the problem differently to write the actual code.

\subsection{Structure of the solution\label{subsection:structure-of-the-solution}}

\subsubsection{The main project\label{subsubsection:the-main-project}}

I have decomposed my solution like so:

\begin{center}
\begin{tikzpicture}[
	every node/.style={rectangle, minimum size=6mm, draw=black, font=\ttfamily, align=center, very thick},
	every path/.style={very thick},
	root/.style={rectangle, text=white, fill=black},
	package/.style={text=white, fill=gray},
	subpackages label/.style={text=white, fill=gray},
	module/.style={text=black, grow=down, anchor=west, edge from parent path={\tikzparentnode.south |- \tikzchildnode.west}},
	vertical/.style={grow=down, xshift=1em, anchor=west, edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}, level distance={#1*6ex}},
	level 1/.style={sibling distance=9.5em},
]
\node [root] {lintrans} [grow=down, level distance=7ex] [edge from parent fork down]
	child {node [module] {\_\_main\_\_}}
	child {node [package] {matrices}
		child [vertical=1] {node [module] {parse}}
		child [vertical=2] {node [module] {wrapper}}
	}
	child {node [package] {gui}
		child [vertical=1] {node [module] {main\_window}}
		child [vertical=2] {node [module] {settings}}
		child [vertical=3] {node [subpackages label] {dialogs...}}
		child [vertical=4] {node [subpackages label] {plots...}}
	};
\end{tikzpicture}
\end{center}

The \texttt{lintrans} node is simply the root of the whole project. \texttt{\_\_main\_\_} is the Python way to make the project executable as \texttt{python -m lintrans} on the command line. For release, I will package it into a standalone binary executable.

\texttt{matrices} is the package that will allow the user to define, validate, parse, evaluate, and use matrices. The \texttt{parse} module will contain functions to validate matrix expressions - likely using regular expressions - and functions to parse matrix expressions. It will not know which matrices are defined, so validation will be na\"{i}ve and evaluation will be elsewhere. The \texttt{wrapper} module will contain a \texttt{MatrixWrapper} class, which will hold a dictionary of matrix names and values. It is this class which will have aware validation - making sure that all matrices are actually defined - as well the ability to evaluate matrix expressions, in addition to its basic behaviour of setting and getting matrices. This \texttt{matrices} package will also have a \texttt{create\_rotation\_matrix} function that will generate a rotation matrix from an angle using the formula $\begin{psmallmatrix}\cos\theta & -\sin\theta\\\sin\theta & \cos\theta\end{psmallmatrix}$. It will be in the \texttt{wrapper} module since it's related to defining and manipulating matrices, but it will be exported and accessible as \texttt{lintrans.matrices.create\_rotation\_matrix}.

\texttt{gui} is the package that will contain all the frontend code for everything GUI-related. \texttt{main\_window} is the module that will contain a \texttt{LintransMainWindow} class, which will act as the main window of the application and have an instance of \texttt{MatrixWrapper} to keep track of which matrices are defined and allow for evaluation of matrix expressions. It will also have methods for rendering and animating matrix expressions, which will be connected to buttons in the GUI. This module will also contain a simple \texttt{main()} function to instantiate and launch the application GUI.

The \texttt{settings} module will contain a \texttt{DisplaySettings} dataclass\footnote{This is the Python equivalent of a \texttt{struct} or \texttt{record} in other languages} that will represent the settings for visualizing transformations. The \texttt{LintransMainWindow} class will have an instance of this class and check against it when rendering things. The user will be able to open a dialog to change these display settings, which will update the main window's instance of this class.

The \texttt{settings} module will also have a \texttt{GlobalSettings} class, which will represent the global settings for the application, such as the logging level, where to save the logs, whether to ask the user if they want to be prompted with a tutorial whenever they open the app, etc. This class will have defaults for everything, but the constructor will try to read these settings from a config file if possible. This allows for persistent settings between sessions. This config file will be \texttt{\textasciitilde/.config/lintrans.conf} on Unix-like systems, including macOS, and \texttt{C:{\textbackslash}Users{\textbackslash}\%USER\%{\textbackslash}AppData{\textbackslash}Roaming{\textbackslash}lintrans{\textbackslash}config.txt} on Windows. This difference is to remain consistent with operating system conventions\footnote{And also to avoid confusing Windows users with a \texttt{.conf} file}.

\subsubsection{The \texttt{gui} subpackages\label{subsubsection:the-gui-subpackages}}

\begin{center}
\begin{tikzpicture}[
	every node/.style={rectangle, minimum size=6mm, draw=black, font=\ttfamily, align=center, very thick},
	every path/.style={very thick},
	root/.style={rectangle, text=white, fill=black},
	package/.style={text=white, fill=gray},
	subpackages label/.style={text=white, fill=gray},
	module/.style={text=black, grow=down, anchor=west, edge from parent path={\tikzparentnode.south |- \tikzchildnode.west}},
	vertical/.style={grow=down, xshift=1em, anchor=west, edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}, level distance={#1*6ex}},
	level 1/.style={sibling distance=12.5em},
]
\node [package] {gui} [grow=down, level distance=7ex] [edge from parent fork down]
	child {node [package] {dialogs}
		child [vertical=1] {node [module] {define\_new\_matrix}}
		child [vertical=2] {node [module] {settings}}
	}
	child {node [package] {plots}
		child [vertical=1] {node [module] {classes}}
		child [vertical=2] {node [module] {widgets}}
	};
\end{tikzpicture}
\end{center}

The \texttt{dialogs} subpackage will contain modules with different dialog classes. It will have a \texttt{define\_new\_matrices} module, which will have a \texttt{DefineDialog} abstract superclass. It will also contain classes that inherit from this superclass and provide dialogs for defining new matrices visually, numerically, and as an expression in terms of other matrices. Additionally, this subpackage will contain a \texttt{settings} module, which will provide a \texttt{SettingsDialog} superclass and a \texttt{DisplaySettingsDialog} class, which will allow the user to configure the aforementioned display settings. It will also have a \texttt{GlobalSettingsDialog} class, which will similarly allow the user to configure the app's global settings through a dialog.

The \texttt{plots} subpackage will have a \texttt{classes} module and a \texttt{widgets} module. The \texttt{classes} module will have the abstract superclasses \texttt{BackgroundPlot} and \texttt{VectorGridPlot}. The former will provide helped methods to convert between coordinate systems and draw the background grid, while the latter will provide helper methods to draw transformations and their components. It will have \texttt{point\_i} and \texttt{point\_j} attributes and will provide methods to draw the transformed version of the grid, the vectors and their arrowheads, the eigenlines of the transformation, etc. These methods can then be called from the Qt5 \texttt{paintEvent} handler which will be declared abstract and must therefore be implemented by all subclasses.

The \texttt{plots} subpackage will also contain a \texttt{widgets} module, which will have the classes \texttt{VisualizeTransformationWidget} and \texttt{DefineVisuallyWidget}, both of which will inherit from \texttt{VectorGridPlot}. They will both implement their own \texttt{paintEvent} handler to actually draw the respective widgets, and \texttt{DefineVisuallyWidget} will also implement handlers for mouse events, allowing the user to drag around the basis vectors.

It's also worth noting here that I don't currently know how I'm going to implement the transformation of arbitrary polygons. It will likely consist of an attribute in \texttt{VisualizeTransformationWidget} which is a list of points, and these points can be dragged around with mouse event handlers and then the transformed versions can be rendered, but I'm not yet sure about how I'm going to implement it.

\subsection{Algorithm design\label{subsection:algorithm-design}}

% TODO: Write pseudocode and/or create flowcharts for this shit

This section will be completed later.

\subsection{Usability features\label{subsection:usability-features}}

My main concern in terms of usability is colour. In the 3blue1brown videos on linear algebra, red and green are used for the basis vectors, but these colours are often hard to distinguish in most common forms of colour blindness. The most common form is deuteranopia\cite{types-of-color-blindness}, which makes red and green look incredibly similar. I will use blue and red for my basis vectors. These colours are easy to distinguish for people with deuteranopia and protanopia - the two most common forms of colour blindness. Tritanopia makes it harder to distinguish blue and yellow, but my colour scheme is still be accessible for people with tritanopia, as red and blue are very distinct in this form of colour blindness.

I will probably use green for the eigenvectors and eigenlines, which will be hard to distinguish from the red basis vector for people with red-green colour blindness, but I think that the basis vectors and eigenvectors/eigenlines will look physically different enough from each other that the colour shouldn't be too much of a problem. Additionally, I will use a tool called Color Oracle\cite{colororacle.org} to make sure that my app is accessible to people with different forms of colour blindness\footnote{I actually had to clone a fork of this project\cite{color-oracle-dorkbox-fork} to get it working on Ubuntu 20.04 and adapt it slightly to create a working \texttt{jar} file}.

Another solution would be to have one default colour scheme, and allow the user to change the colour scheme to something more accessible for colour blind people, but I don't see the point in this. I think it's easier for colour blind people to just have the main colour scheme be accessible, and it's not really an inconvenience to non-colour blind people, so I think this is the best option.

The layout of my app will be self-consistent and follow standard conventions. I will have a menu bar at the top of the main window for actions like saving and loading, as well as accessing the tutorial (which will also be accessible by pressing \texttt{F1} at any point) and documentation. The dialogs will always have the confirm button in the bottom right and the cancel button just to the left of that. They will also have the matrix name drop-down on the left. This consistency will make the app easier to learn and understand.

I will also have hotkeys for everything that can have hotkeys - buttons, checkboxes, etc. This makes my life easier, since I'm used to having hotkeys for everything, and thus makes the app faster to test because I don't need to click everything. This also makes things easier for other people like me, who prefer to stay at the keyboard and not use the mouse. Obviously a mouse will be required for things like dragging basis vectors and polygon vertices, but hotkeys will be available wherever possible to help people who don't like using the mouse or find it difficult.

\subsection{Variables and validation\label{subsection:variables-and-validation}}

This project won't actually have many variables. The main ones will be instance attributes on the \texttt{LintransMainWindow} class. It will have a \texttt{MatrixWrapper} instance, a \texttt{DisplaySettings} instance, and a \texttt{GlobalSettings} instance. These will handle the matrices and various settings respectively. Having these as instance attributes allows them to be referenced from any method in the class, and Qt5 uses lots of slots (basically callback methods) and handlers, so it's good to be able to access the attributes I need right there rather than having to pass them around from method to method.

The \texttt{MatrixWrapper} class will have a dictionary of names and matrices. The names will be single letters\footnote{I would make these \texttt{char} but Python only has a \texttt{str} type for strings} and the matrices will be of type \texttt{MatrixType}. This will be a custom type alias representing a $2 \times 2$ \texttt{numpy} array of floats. When setting the values for these matrices, I will have to manually check the types. This is because Python has weak typing, and if we got, say, an integer in place of a matrix, then operations would fail when trying to evaluate a matrix expression, and the program would crash. To prevent this, we have to validate the type of every matrix when it's set. I have chosen to use a dictionary here because it makes accessing a matrix by its name easier. We don't have to check against a list of letters and another list of matrices, we just index into the dictionary.

The settings dataclasses will have instance attributes for each setting. Most of these will be booleans, since they will be simple binary options like \textit{Show determinant}, which will be represented with checkboxes in the GUI. The \texttt{DisplaySettings} dataclass will also have an attribute of type \texttt{int} representing the time in milliseconds to pause during animations.

The \texttt{DefineDialog} superclass have a \texttt{MatrixWrapper} instance attribute, which will be a parameter in the constructor. When \texttt{LintransMainWindow} spawns a definition dialog (which subclasses \texttt{DefineDialog}), it will pass in a copy of its own \texttt{MatrixWrapper} and connect the \texttt{accepted} signal for the dialog. The slot (method) that this signal is connected to will get called when the dialog is closed with the \textit{Confirm} button\footnote{Actually when the dialog calls \texttt{.accept()}. The \texttt{Confirm} button is actually connected to a method which first takes the info and updates the instance \texttt{MatrixWrapper}, and then calls \texttt{.accept()}}. This allows the dialog to mutate its own \texttt{MatrixWrapper} object and then the main window can copy that mutated version back into its own instance attribute when the user confirms the change. This reduces coupling and makes everything easier to reason about and debug, as well as reducing the number of bugs, since the classes will be independent of each other. In another language, I could pass a pointer to the wrapper and let the dialog mutate it directly, but this is potentially dangerous, and Python doesn't have pointers anyway.

Validation will also play a very big role in the application. The user will be able to enter matrix expressions and these must be validated. I will define a BNF schema and either write my own RegEx or use that BNF to programmatically generate a RegEx. Every matrix expression input will be checked against it. This is to ensure that the matrix wrapper can actually evaluate the expression. If we didn't validate the expression, then the parsing would fail and the program could crash. I've chosen to use a RegEx here rather than any other option because it's the simplest. Creating a RegEx can be difficult, especially for complicated patterns, but it's then easier to use it. Also, Python can compile a RegEx pattern, which makes it much faster to match against, so I will compile the pattern at initialization time and just compare expressions against that pre-compiled pattern, since we know it won't change at runtime.

Additionally, the buttons to render and animate the current matrix expression will only be enabled when the expression is valid. Textboxes in Qt5 emit a \texttt{textChanged} signal, which can be connected to a slot. This is just a method that gets called whenever the text in the textbox is changed, so I can use this method to validate the input and update the buttons accordingly. An empty string will count as invalid, so the buttons will be disabled when the box is empty.

I will also apply this matrix expression validation to the textbox in the dialog which allows the user to define a matrix as an expression involving other matrices, and I will validate the input in the numeric definition dialog to make sure that all the inputs are floats. Again, this is to prevent crashes, since a matrix with non-number values in it will likely crash the program.

\subsection{Iterative test data\label{subsection:iterative-test-data}}

% TODO: Improve this

In unit testing, I will test the validation, parsing, and generation of rotation matrices from an angle. I will also unit test the utility functions for the GUI, like \texttt{is\_valid\_float}.

For the validation of matrix expressions, I will have data like the following:
\begin{center}
\begin{tabular}{|c|c|}
\hline
Valid & Invalid\\
\hline
\texttt{"A"} & \texttt{""}\\
\hline
\texttt{"AB"} & \texttt{"A\textasciicircum"}\\
\hline
\texttt{"-3.4A"} & \texttt{"rot()"}\\
\hline
\texttt{"A\textasciicircum2"} & \texttt{"A\textasciicircum\{2"}\\
\hline
\texttt{"A\textasciicircum T"} & \texttt{"\textasciicircum12"}\\
\hline
\texttt{"A\textasciicircum\{-1\}"} & \texttt{"A\textasciicircum3.2"}\\
\hline
\texttt{"rot(45)"} & \texttt{"A\textasciicircum B"}\\
\hline
\texttt{"3A\textasciicircum\{12\}"} & \texttt{".A"}\\
\hline
\texttt{"2B\textasciicircum2+A\textasciicircum TC\textasciicircum\{-1\}"} & \texttt{"--A"}\\
\hline
\texttt{"3.5A\textasciicircum{4}5.6rot(19.2\textasciicircum T-B\textasciicircum{-1}4.1C\textasciicircum5"} & \texttt{"A--B"}\\
\hline
\end{tabular}
\end{center}

This list is not exhaustive, mostly to save space and time, but the full unit testing code is included in appendix \ref{appendix:testing-code}.

The invalid expressions presented here have been chosen to be almost valid, but not quite. They are edge cases. I will also test blatantly invalid expressions like \texttt{"This is a matrix expression"} to make sure the validation works.

Here's an example of some test data for parsing:\vspace{-1em}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Input & Expected\\
\hline
\texttt{"A"} & \texttt{[[("", "A", "")]]}\\
\hline
\texttt{"AB"} & \texttt{[[("", "A", ""), ("", "B", "")]]}\\
\hline
\texttt{"2A+B\textasciicircum2"} & \texttt{[[("2", "A", ""), ("", "B", "2")]]}\\
\hline
\texttt{"3A\textasciicircum T2.4B\textasciicircum\{-1\}-C"} & \texttt{[[("3", "A", "T"), ("2.4", "B", "-1")], [("-1", "C", "")]]}\\
\hline
\end{tabular}
\end{center}

The parsing output is pretty verbose and this table doesn't have enough space for most of the more complicated inputs, so here's a monster one:
\begin{center}
\texttt{"2.14A\textasciicircum\{3\} 4.5rot(14.5)\textasciicircum-1 + 8.5B\textasciicircum T 5.97C\textasciicircum14 - 3.14D\textasciicircum\{-1\} 6.7E\textasciicircum T"}
\end{center}
which should parse to give:
\begin{center}
\texttt{[[("2.14", "A", "3"), ("4.5", "rot(14.5)", "-1")], [("8.5", "B", "T"), ("5.97", "C", "14")], [("-3.14", "D", "-1"), ("6.7", "E", "T")]]}
\end{center}

Any invalid expression will also raise a parse error, so I will check every invalid input previously mentioned and make sure it raises the appropriate error.

Again, this section is brief to save space and time. All unit tests are included in appendix \ref{appendix:testing-code}.

\subsection{Post-development test data\label{subsection:post-development-test-data}}

% TODO: Finish this

This section will be completed later.

\end{document}
