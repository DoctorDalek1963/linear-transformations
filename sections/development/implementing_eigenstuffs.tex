% lintrans - The linear transformation visualizer
% Copyright (C) 2021-2022 D. Dyson (DoctorDalek1963)

% This program is licensed under GNU GPLv3, available here:
% <https://www.gnu.org/licenses/gpl-3.0.html>

\documentclass[../development.tex]{subfiles}

\begin{document}

It's not universal, but the word \enquote{eigenstuffs} is common enough in mathematics that I'm comfortable using it here to mean eigenvalues, eigenvectors, and eigenlines, where an eigenline is the span of an eigenvector.

\subsubsection{Drawing eigenvectors\label{development:implementing-eigenstuffs:drawing-eigenvectors}}

An eigenvector $\mathbf{v}$ of a matrix $\mathbf{M}$ is a vector that satisfies the equation $\mathbf{Mv} = \lambda\mathbf{v}$ for some scalar $\lambda$. Thankfully, I don't have to worry about actually computing $\mathbf{v}$ or $\lambda$, since NumPy has the \pyinline{numpy.linalg.eig()} function\cite{numpy-docs-linalg-eig}.

This function takes a square matrix and returns an array of eigenvalues ($\lambda$), and a matrix of their associated eigenvectors ($\mathbf{v}$). Some matrices don't have any real eigenvalues, but all $2 \times 2$ matrices will have 2 (possibly complex) eigenvalues, as a direct consequence of the Fundamental Theorem of Algebra\footnote{%
	$\mathbf{Mv} = \lambda\mathbf{v} \implies \mathbf{Mv} = \lambda\mathbf{I}\mathbf{v} \implies (\mathbf{M} - \lambda\mathbf{I})\mathbf{v} = \mathbf{0} \implies \det(\mathbf{M} - \lambda\mathbf{I}) = 0\text{ (since we only want non-zero vectors)}\\%
\implies \begin{vmatrix}a - \lambda & b\\ c & d - \lambda\end{vmatrix} = 0 \implies (a - \lambda)(d - \lambda) - bc = 0 \implies \lambda^2 - (a + d)\lambda + (ad - bc) = 0 \\%
\implies \lambda$ has 2 solutions in $\mathbb{C}$ by the Fundamental Theorem of Algebra\cite{the-fundamental-theorem-of-algebra}%
}. We don't want to try to render an eigenvector if its eigenvalue is complex, so we have to check and only render the real ones. Python doesn't distinguish really between \pyinline{float} and \pyinline{complex} types, so we can just check the \pyinline{.imag} property no matter what. If it's 0, then we keep the eigenvalue. NumPy normalizes the eigenvectors to have a length of 1, but I'd much prefer them to have a length equal to their associated eigenvalue. To do that, we can just multiply the eigenvectors by their eigenvalues.

We then just draw a vector, consisting of a line and an arrowhead, from the origin to the extended eigenvector.

%: b8614334de5cba4b1a6d92508b08fa8bd2fe77c0
%: src/lintrans/gui/plots/classes.py:163,450-465

%: b8614334de5cba4b1a6d92508b08fa8bd2fe77c0
%: src/lintrans/gui/plots/widgets.py:58

At this point in development, I didn't particularly care about the colours of various elements. It was more important to get things working first, so I ended up choosing \textcolor[RGB]{255, 249, 0}{this horrible yellow} for the eigenvectors. It's clearly an awful choice for text, and it's not very good for the eigenvectors either, since it makes them hard to see against the white background. I wasn't really considering the usability features discussed in \S\ref{design:usability-features}, but since I was the only user, and changing a few colours later on wouldn't be much work, I wasn't worried about it.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{development/b8614334de5cba4b1a6d92508b08fa8bd2fe77c0/gui.png}
	\caption{The eigenvectors being displayed for an arbitrary matrix}
	\label{fig:development:b8614334de5cba4b1a6d92508b08fa8bd2fe77c0:gui.png}
\end{figure}

\subsubsection{Adding display settings for eigenvectors\label{development:implementing-eigenstuffs:adding-display-settings-for-eigenvectors}}

Once I'd got the eigenvectors working and being drawn, I wanted to be able to turn them on and off from the display settings. This was a simple case of just adding it to the \pyinline{DisplaySettings} dataclass, adding the checkbox to the dialog, and only drawing the eigenvectors if this display setting is true.

%: 3ebb5997a7a887e751b5f4f717aa5161ed013e62
%: src/lintrans/gui/settings.py:41-42

%: 3ebb5997a7a887e751b5f4f717aa5161ed013e62
%: src/lintrans/gui/dialogs/settings.py:123-126

%: 3ebb5997a7a887e751b5f4f717aa5161ed013e62
%: src/lintrans/gui/plots/widgets.py:58-59

\subsubsection{Refactoring drawing vectors\label{development:implementing-eigenvectors:refactoring-drawing-vectors}}

Since I've now got several drawing methods that involve drawing vectors, I thought I should factor out this functionality into a separate utility method which I could call from all these places.

%: 754eba0318a682b068a8a5d5ca451decbaa204ce
%: src/lintrans/gui/plots/classes.py:388-406,454-466

When I was testing this refactor, I realised that the \pyinline{draw_transformed_grid()} method originally drew the bodies of the basis vectors and the caller had to draw the arrowheads separately. This is silly and was never planned that way; it was an unfortunate consequence of implementing the lines and arrowheads at different times. But now after this refactor, the caller has to call \pyinline{draw_basis_vectors()} to draw the whole basis vectors. So I had to add this call to \pyinline{VisualizeTransformationWidget.paintEvent()} and \pyinline{DefineVisuallyWidget.paintEvent()} in \texttt{src/lintrans/gui/plots/widgets.py} and remove the calls to \pyinline{draw_vector_arrowheads()}.

\end{document}
